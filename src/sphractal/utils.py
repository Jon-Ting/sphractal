from collections import defaultdict
from itertools import combinations, product
from math import ceil, dist, floor, sqrt
import numpy as np
from scipy.spatial import ConvexHull, Delaunay
from time import time
from .constants import ATOMIC_RAD_DICT, BULK_CN, NN_RAD_MULT


def estDuration(func):
    """Wrapper to measure run time of function."""
    def wrap(*arg, **kwargs):
        start = time()
        result = func(*arg, **kwargs)
        end = time()
        duration = end - start
        # print(f"*** Function {func.__name__}\tDuration: {duration:.6f} s\n")
        return result, duration
    return wrap


class Atom(object):
    """Object to store information about any particular atom."""
    def __init__(self, atomIdx, eleXYZ):
        self.ID = atomIdx
        self.ele = eleXYZ[-4]
        self.X, self.Y, self.Z = float(eleXYZ[-3]), float(eleXYZ[-2]), float(eleXYZ[-1])
        self.neighs = []
        self.isSurf = 0  # int(eleXYZ[4]) from 'ov_SURF_layer.xyz' generated by NCPac
        self.avgBondLen = 0.0


def readXYZ(filePath):
    """Read in .xyz or .lmp file and store the atomic information."""
    atoms, eleSet = [], set()
    maxX, maxY, maxZ, minX, minY, minZ = 0.0, 0.0, 0.0, 1000.0, 1000.0, 1000.0
    numLinesSkip = 9 if '.lmp' in filePath else 2
    with open(filePath, 'r') as f:
        for (i, line) in enumerate(f):
            if i < numLinesSkip:
                continue
            atom = Atom(i - numLinesSkip, line.split())
            if atom.X > maxX:
                maxX = atom.X
            if atom.X < minX:
                minX = atom.X
            if atom.Y > maxY:
                maxY = atom.Y
            if atom.Y < minY:
                minY = atom.Y
            if atom.Z > maxZ:
                maxZ = atom.Z
            if atom.Z < minZ:
                minZ = atom.Z
            atoms.append(atom)
            if ATOMIC_RAD_DICT[atom.ele] not in eleSet:
                eleSet.add(atom.ele)
    maxDimDiff = max(maxX - minX, maxY - minY, maxZ - minZ)
    return tuple(atoms), maxDimDiff, eleSet, (minX, minY, minZ, maxX, maxY, maxZ)


def findNN(atoms, minMaxXYZs, maxAtomRad, calcBL=False):
    """Populate nearest neighbour list of each atom."""
    minX, minY, minZ, maxX, maxY, maxZ = minMaxXYZs
    allDirections = [dirVec for dirVec in product(range(-1, 2), repeat=3)]
    stepSize = ceil(maxAtomRad*2)
    numX, numY, numZ = ceil((maxX-minX) / stepSize), ceil((maxY-minY) / stepSize), ceil((maxZ-minZ) / stepSize)
    boxes = [[[[] for _ in range(numZ)] for _ in range(numY)] for _ in range(numX)]
    for (i, atom1) in enumerate(atoms):
        x, y, z = floor((atom1.X-minX) / stepSize), floor((atom1.Y-minY) / stepSize), floor((atom1.Z-minZ) / stepSize)
        for (dirX, dirY, dirZ) in allDirections:
            if 0 <= x + dirX < numX and 0 <= y + dirY < numY and 0 <= z + dirZ < numZ:
                for j in boxes[x + dirX][y + dirY][z + dirZ]:
                    atom2 = atoms[j]
                    diffX, diffY, diffZ = abs(atom1.X - atom2.X), abs(atom1.Y - atom2.Y), abs(atom1.Z - atom2.Z)
                    sumOfSquares = diffX * diffX + diffY * diffY + diffZ * diffZ
                    if sumOfSquares < ((ATOMIC_RAD_DICT[atom1.ele]+ATOMIC_RAD_DICT[atom2.ele])*NN_RAD_MULT) ** 2:
                        atom1.neighs.append(j)
                        atom2.neighs.append(i)
                        if calcBL:
                            atom1.avgBondLen += sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ)
                            atom2.avgBondLen += sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ)
        boxes[x][y][z].append(i)
    if calcBL:
        for atom in atoms:
            atom.avgBondLen /= len(atom.neighs)


def findSurf(atoms, option='alphaShape', alpha=2.5):
    """
    Identify surface atoms and update the Atom objects.

    convexHull:
        - Tend to identify less than actual surface atoms
    numNeigh:
        - Tend to identify more than actual surface atoms
    alphaShape:
        - Generalisation of convex hull
        - Algorithm modified from https://stackoverflow.com/questions/26303878/alpha-shapes-in-3d
        - Radius of the sphere fitting inside the tetrahedral < alpha (http://mathworld.wolfram.com/Circumsphere.html)

    Alternatives:
    - https://dl.acm.org/doi/abs/10.1145/2073304.2073339
    - https://onlinelibrary.wiley.com/doi/pdf/10.1002/jcc.25384
    - https://www.jstage.jst.go.jp/article/tmrsj/45/4/45_115/_article
    """
    if option == 'convexHull':
        atomXYZs = np.array([[atom.X, atom.Y, atom.Z] for atom in atoms])
        for atomIdx in ConvexHull(atomXYZs).vertices:
            atoms[atomIdx].isSurf = 1
    elif option == 'numNeigh':
        for atom in atoms:
            if len(atom.neighs) < BULK_CN:
                atom.isSurf = 1
    elif option == 'alphaShape':
        atomXYZs = np.array([[atom.X, atom.Y, atom.Z] for atom in atoms])
        tetraVtxsIdxs = Delaunay(atomXYZs).simplices

        # Find radius of the circumsphere
        tetraVtxs = np.take(atomXYZs, tetraVtxsIdxs, axis=0)
        norm2 = np.sum(tetraVtxs ** 2, axis=2)[:, :, None]
        ones = np.ones((tetraVtxs.shape[0], tetraVtxs.shape[1], 1))
        a = np.linalg.det(np.concatenate((tetraVtxs, ones), axis=2))
        Dx = np.linalg.det(np.concatenate((norm2, tetraVtxs[:, :, [1, 2]], ones), axis=2))
        Dy = np.linalg.det(np.concatenate((norm2, tetraVtxs[:, :, [0, 2]], ones), axis=2))
        Dz = np.linalg.det(np.concatenate((norm2, tetraVtxs[:, :, [0, 1]], ones), axis=2))
        c = np.linalg.det(np.concatenate((norm2, tetraVtxs), axis=2))
        with np.errstate(divide='ignore', invalid='ignore'):
            r = np.sqrt(Dx**2 + Dy**2 + Dz**2 - 4*a*c) / (2*np.abs(a))

        # Find tetrahedrons and triangles
        tetras = tetraVtxsIdxs[r < alpha, :]
        triComb = np.array([(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)])
        tris = tetras[:, triComb].reshape(-1, 3)
        tris = np.sort(tris, axis=1)

        # Remove triangles that occur twice, because they are internal
        trisDict = defaultdict(int)
        for tri in tris:
            trisDict[tuple(tri)] += 1
        tris = tuple(tri for tri in trisDict if trisDict[tri] == 1)
        npVtxs = np.unique(np.concatenate(np.array(tris)))
        for atomIdx in npVtxs:
            atoms[atomIdx].isSurf = 1


def closestSurfAtoms(pointXYZ, surfNeighXYZs, surfNeighIdxs, atoms):
    """Identify two closest surface atom pairs from pointXYZ, that are neighbour of each other."""
    if len(surfNeighXYZs) == 0:
        return None, None
    elif len(surfNeighXYZs) == 1:
        closestAtom = atoms[surfNeighIdxs[0]]
        return np.array((closestAtom.X, closestAtom.Y, closestAtom.Z)), None

    surfNeighDists = tuple(dist(surfNeighXYZ, pointXYZ) for surfNeighXYZ in surfNeighXYZs)
    closestSurfAtomIdxs = tuple(idx for _, idx in sorted(zip(surfNeighDists, surfNeighIdxs), key=lambda pair: pair[0]))
    atom1 = atoms[closestSurfAtomIdxs[0]]
    for atomIdxs in combinations(closestSurfAtomIdxs, 2):
        if atoms[atomIdxs[0]].ID in atoms[atomIdxs[1]].neighs:
            atom1, atom2 = atoms[atomIdxs[0]], atoms[atomIdxs[1]]
            return np.array((atom1.X, atom1.Y, atom1.Z)), np.array((atom2.X, atom2.Y, atom2.Z))
    return np.array((atom1.X, atom1.Y, atom1.Z)), None


def oppositeInnerAtoms(pointXYZ, atom1, atoms):
    """Check if pointXYZ lies on the opposite side of average coordinates of neighbouring inner atoms of atom1."""
    atom1XYZ = np.array((atom1.X, atom1.Y, atom1.Z))
    surfNeighIdxs, surfNeighXYZs, bulkNeighXYZs = [], [], []
    for idx in atom1.neighs:
        if atoms[idx].isSurf:
            surfNeighIdxs.append(idx)
            surfNeighXYZs.append(np.array((atoms[idx].X, atoms[idx].Y, atoms[idx].Z)))
        else:
            bulkNeighXYZs.append(np.array((atoms[idx].X, atoms[idx].Y, atoms[idx].Z)))

    # Average coordinates of inner atoms relative to atom1
    avgInnerAtomXYZ = np.array(bulkNeighXYZs).mean(0) if bulkNeighXYZs else np.array(surfNeighXYZs).mean(0)
    atom2XYZ, atom3XYZ = closestSurfAtoms(pointXYZ, surfNeighXYZs, surfNeighIdxs, atoms)
    if (atom2XYZ is None) or (atom3XYZ is None):
        normal = avgInnerAtomXYZ - atom1XYZ
    else:
        normal = np.cross(atom2XYZ - atom1XYZ, atom3XYZ - atom1XYZ)
    return np.dot(normal, avgInnerAtomXYZ - atom1XYZ) * np.dot(normal, pointXYZ - atom1XYZ) < 0
